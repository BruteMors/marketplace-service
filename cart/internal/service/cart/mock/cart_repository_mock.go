// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/BruteMors/marketplace-service/cart/internal/service/cart.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/BruteMors/marketplace-service/cart/internal/models"
	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements cart.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, userID int64, skuID int64, count uint16) (err error)
	inspectFuncAdd   func(ctx context.Context, userID int64, skuID int64, count uint16)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mCartRepositoryMockAdd

	funcDeleteItem          func(ctx context.Context, userID int64, skuID int64) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userID int64, skuID int64)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartRepositoryMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, userID int64) (i1 int, err error)
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, userID int64)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mCartRepositoryMockDeleteItemsByUserID

	funcGetCart          func(ctx context.Context, userID int64) (ia1 []models.ItemCount, err error)
	inspectFuncGetCart   func(ctx context.Context, userID int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart
}

// NewCartRepositoryMock returns a mock for cart.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mCartRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*CartRepositoryMockAddParams{}

	m.DeleteItemMock = mCartRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartRepositoryMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mCartRepositoryMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*CartRepositoryMockDeleteItemsByUserIDParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAdd struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddExpectation
	expectations       []*CartRepositoryMockAddExpectation

	callArgs []*CartRepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockAddExpectation specifies expectation struct of the CartRepository.Add
type CartRepositoryMockAddExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockAddParams
	paramPtrs *CartRepositoryMockAddParamPtrs
	results   *CartRepositoryMockAddResults
	Counter   uint64
}

// CartRepositoryMockAddParams contains parameters of the CartRepository.Add
type CartRepositoryMockAddParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
	count  uint16
}

// CartRepositoryMockAddParamPtrs contains pointers to parameters of the CartRepository.Add
type CartRepositoryMockAddParamPtrs struct {
	ctx    *context.Context
	userID *int64
	skuID  *int64
	count  *uint16
}

// CartRepositoryMockAddResults contains results of the CartRepository.Add
type CartRepositoryMockAddResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mCartRepositoryMockAdd) Optional() *mCartRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) Expect(ctx context.Context, userID int64, skuID int64, count uint16) *mCartRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &CartRepositoryMockAddParams{ctx, userID, skuID, count}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CartRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAdd
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) ExpectUserIDParam2(userID int64) *mCartRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CartRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.userID = &userID

	return mmAdd
}

// ExpectSkuIDParam3 sets up expected param skuID for CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CartRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.skuID = &skuID

	return mmAdd
}

// ExpectCountParam4 sets up expected param count for CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) ExpectCountParam4(count uint16) *mCartRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &CartRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.count = &count

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) Inspect(f func(ctx context.Context, userID int64, skuID int64, count uint16)) *mCartRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by CartRepository.Add
func (mmAdd *mCartRepositoryMockAdd) Return(err error) *CartRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &CartRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &CartRepositoryMockAddResults{err}
	return mmAdd.mock
}

// Set uses given function f to mock the CartRepository.Add method
func (mmAdd *mCartRepositoryMockAdd) Set(f func(ctx context.Context, userID int64, skuID int64, count uint16) (err error)) *CartRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the CartRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the CartRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the CartRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mCartRepositoryMockAdd) When(ctx context.Context, userID int64, skuID int64, count uint16) *CartRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("CartRepositoryMock.Add mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddExpectation{
		mock:   mmAdd.mock,
		params: &CartRepositoryMockAddParams{ctx, userID, skuID, count},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.Add return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddResults{err}
	return e.mock
}

// Times sets number of times CartRepository.Add should be invoked
func (mmAdd *mCartRepositoryMockAdd) Times(n uint64) *mCartRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of CartRepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	return mmAdd
}

func (mmAdd *mCartRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements cart.CartRepository
func (mmAdd *CartRepositoryMock) Add(ctx context.Context, userID int64, skuID int64, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, userID, skuID, count)
	}

	mm_params := CartRepositoryMockAddParams{ctx, userID, skuID, count}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddParams{ctx, userID, skuID, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("CartRepositoryMock.Add got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAdd.t.Errorf("CartRepositoryMock.Add got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmAdd.t.Errorf("CartRepositoryMock.Add got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAdd.t.Errorf("CartRepositoryMock.Add got unexpected parameter count, want: %#v, got: %#v%s\n", *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("CartRepositoryMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the CartRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, userID, skuID, count)
	}
	mmAdd.t.Fatalf("Unexpected call to CartRepositoryMock.Add. %v %v %v %v", ctx, userID, skuID, count)
	return
}

// AddAfterCounter returns a count of finished CartRepositoryMock.Add invocations
func (mmAdd *CartRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of CartRepositoryMock.Add invocations
func (mmAdd *CartRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mCartRepositoryMockAdd) Calls() []*CartRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.Add with params: %#v", *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.Add")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.Add")
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.Add but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), afterAddCounter)
	}
}

type mCartRepositoryMockDeleteItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemExpectation
	expectations       []*CartRepositoryMockDeleteItemExpectation

	callArgs []*CartRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockDeleteItemExpectation specifies expectation struct of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockDeleteItemParams
	paramPtrs *CartRepositoryMockDeleteItemParamPtrs
	results   *CartRepositoryMockDeleteItemResults
	Counter   uint64
}

// CartRepositoryMockDeleteItemParams contains parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userID int64
	skuID  int64
}

// CartRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *int64
	skuID  *int64
}

// CartRepositoryMockDeleteItemResults contains results of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Optional() *mCartRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Expect(ctx context.Context, userID int64, skuID int64) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartRepositoryMockDeleteItemParams{ctx, userID, skuID}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteItem
}

// ExpectSkuIDParam3 sets up expected param skuID for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectSkuIDParam3(skuID int64) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.skuID = &skuID

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userID int64, skuID int64)) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Return(err error) *CartRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartRepositoryMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartRepository.DeleteItem method
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Set(f func(ctx context.Context, userID int64, skuID int64) (err error)) *CartRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the CartRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartRepositoryMockDeleteItem) When(ctx context.Context, userID int64, skuID int64) *CartRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &CartRepositoryMockDeleteItemParams{ctx, userID, skuID},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItem should be invoked
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Times(n uint64) *mCartRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	return mmDeleteItem
}

func (mmDeleteItem *mCartRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements cart.CartRepository
func (mmDeleteItem *CartRepositoryMock) DeleteItem(ctx context.Context, userID int64, skuID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, skuID)
	}

	mm_params := CartRepositoryMockDeleteItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartRepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Calls() []*CartRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem with params: %#v", *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteItem")
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItem but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), afterDeleteItemCounter)
	}
}

type mCartRepositoryMockDeleteItemsByUserID struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemsByUserIDExpectation
	expectations       []*CartRepositoryMockDeleteItemsByUserIDExpectation

	callArgs []*CartRepositoryMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockDeleteItemsByUserIDExpectation specifies expectation struct of the CartRepository.DeleteItemsByUserID
type CartRepositoryMockDeleteItemsByUserIDExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockDeleteItemsByUserIDParams
	paramPtrs *CartRepositoryMockDeleteItemsByUserIDParamPtrs
	results   *CartRepositoryMockDeleteItemsByUserIDResults
	Counter   uint64
}

// CartRepositoryMockDeleteItemsByUserIDParams contains parameters of the CartRepository.DeleteItemsByUserID
type CartRepositoryMockDeleteItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockDeleteItemsByUserIDParamPtrs contains pointers to parameters of the CartRepository.DeleteItemsByUserID
type CartRepositoryMockDeleteItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockDeleteItemsByUserIDResults contains results of the CartRepository.DeleteItemsByUserID
type CartRepositoryMockDeleteItemsByUserIDResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Optional() *mCartRepositoryMockDeleteItemsByUserID {
	mmDeleteItemsByUserID.optional = true
	return mmDeleteItemsByUserID
}

// Expect sets up expected params for CartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Expect(ctx context.Context, userID int64) *mCartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &CartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &CartRepositoryMockDeleteItemsByUserIDParams{ctx, userID}
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &CartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) ExpectUserIDParam2(userID int64) *mCartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &CartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by CartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Return(i1 int, err error) *CartRepositoryMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &CartRepositoryMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &CartRepositoryMockDeleteItemsByUserIDResults{i1, err}
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the CartRepository.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Set(f func(ctx context.Context, userID int64) (i1 int, err error)) *CartRepositoryMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the CartRepository.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) When(ctx context.Context, userID int64) *CartRepositoryMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemsByUserIDExpectation{
		mock:   mmDeleteItemsByUserID.mock,
		params: &CartRepositoryMockDeleteItemsByUserIDParams{ctx, userID},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemsByUserIDExpectation) Then(i1 int, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemsByUserIDResults{i1, err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItemsByUserID should be invoked
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Times(n uint64) *mCartRepositoryMockDeleteItemsByUserID {
	if n == 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsByUserID.expectedInvocations, n)
	return mmDeleteItemsByUserID
}

func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) invocationsDone() bool {
	if len(mmDeleteItemsByUserID.expectations) == 0 && mmDeleteItemsByUserID.defaultExpectation == nil && mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.mock.afterDeleteItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsByUserID implements cart.CartRepository
func (mmDeleteItemsByUserID *CartRepositoryMock) DeleteItemsByUserID(ctx context.Context, userID int64) (i1 int, err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, userID)
	}

	mm_params := CartRepositoryMockDeleteItemsByUserIDParams{ctx, userID}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, &mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemsByUserID.t.Errorf("CartRepositoryMock.DeleteItemsByUserID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItemsByUserID.t.Errorf("CartRepositoryMock.DeleteItemsByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("CartRepositoryMock.DeleteItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the CartRepositoryMock.DeleteItemsByUserID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, userID)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItemsByUserID. %v %v", ctx, userID)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished CartRepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *CartRepositoryMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of CartRepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *CartRepositoryMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mCartRepositoryMockDeleteItemsByUserID) Calls() []*CartRepositoryMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemsByUserIDDone() bool {
	if m.DeleteItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsByUserIDMock.invocationsDone()
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUserID with params: %#v", *e.params)
		}
	}

	afterDeleteItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && afterDeleteItemsByUserIDCounter < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteItemsByUserID")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUserID with params: %#v", *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && afterDeleteItemsByUserIDCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteItemsByUserID")
	}

	if !m.DeleteItemsByUserIDMock.invocationsDone() && afterDeleteItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItemsByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsByUserIDMock.expectedInvocations), afterDeleteItemsByUserIDCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock      *CartRepositoryMock
	params    *CartRepositoryMockGetCartParams
	paramPtrs *CartRepositoryMockGetCartParamPtrs
	results   *CartRepositoryMockGetCartResults
	Counter   uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	ia1 []models.ItemCount
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, userID}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetCart
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIDParam2(userID int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(ia1 []models.ItemCount, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{ia1, err}
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, userID int64) (ia1 []models.ItemCount, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, userID int64) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &CartRepositoryMockGetCartParams{ctx, userID},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(ia1 []models.ItemCount, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{ia1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements cart.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, userID int64) (ia1 []models.ItemCount, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userID)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, userID)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart with params: %#v", *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.GetCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Error("Expected call to CartRepositoryMock.GetCart")
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), afterGetCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserIDInspect()

			m.MinimockGetCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetCartDone()
}
