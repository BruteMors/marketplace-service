// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: reserve.sql

package sqlc

import (
	"context"
)

const getItemsAvailability = `-- name: GetItemsAvailability :many
SELECT sku, (total_count - reserved) AS available
FROM items
WHERE sku = ANY($1::int[])
  FOR UPDATE
`

type GetItemsAvailabilityRow struct {
	Sku       int32
	Available int32
}

func (q *Queries) GetItemsAvailability(ctx context.Context, sku []int32) ([]GetItemsAvailabilityRow, error) {
	rows, err := q.db.Query(ctx, getItemsAvailability, sku)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsAvailabilityRow
	for rows.Next() {
		var i GetItemsAvailabilityRow
		if err := rows.Scan(&i.Sku, &i.Available); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservedItems = `-- name: UpdateReservedItems :exec
WITH unnested_data AS (
  SELECT unnest($1::int[]) AS sku, unnest($2::int[]) AS count
)
UPDATE items
SET reserved = items.reserved + ud.count
FROM unnested_data ud
WHERE items.sku = ud.sku AND (items.total_count - items.reserved) >= ud.count
`

type UpdateReservedItemsParams struct {
	Sku   []int32
	Count []int32
}

func (q *Queries) UpdateReservedItems(ctx context.Context, arg UpdateReservedItemsParams) error {
	_, err := q.db.Exec(ctx, updateReservedItems, arg.Sku, arg.Count)
	return err
}
