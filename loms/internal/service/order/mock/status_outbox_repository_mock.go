// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/BruteMors/marketplace-service/loms/internal/service/order.StatusOutboxRepository -o status_outbox_repository_mock.go -n StatusOutboxRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	ordermodels "github.com/BruteMors/marketplace-service/loms/internal/models/order"
	"github.com/gojuno/minimock/v3"
)

// StatusOutboxRepositoryMock implements order.StatusOutboxRepository
type StatusOutboxRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrderStatusChangedEvent          func(ctx context.Context, orderID int64, status ordermodels.Status) (err error)
	inspectFuncCreateOrderStatusChangedEvent   func(ctx context.Context, orderID int64, status ordermodels.Status)
	afterCreateOrderStatusChangedEventCounter  uint64
	beforeCreateOrderStatusChangedEventCounter uint64
	CreateOrderStatusChangedEventMock          mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent

	funcFetchNextOrderStatusChangedEvent          func(ctx context.Context) (s1 ordermodels.StatusChangedEvent, err error)
	inspectFuncFetchNextOrderStatusChangedEvent   func(ctx context.Context)
	afterFetchNextOrderStatusChangedEventCounter  uint64
	beforeFetchNextOrderStatusChangedEventCounter uint64
	FetchNextOrderStatusChangedEventMock          mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent

	funcMarkOrderStatusChangedEventAsSend          func(ctx context.Context, eventID int64) (err error)
	inspectFuncMarkOrderStatusChangedEventAsSend   func(ctx context.Context, eventID int64)
	afterMarkOrderStatusChangedEventAsSendCounter  uint64
	beforeMarkOrderStatusChangedEventAsSendCounter uint64
	MarkOrderStatusChangedEventAsSendMock          mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend
}

// NewStatusOutboxRepositoryMock returns a mock for order.StatusOutboxRepository
func NewStatusOutboxRepositoryMock(t minimock.Tester) *StatusOutboxRepositoryMock {
	m := &StatusOutboxRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderStatusChangedEventMock = mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent{mock: m}
	m.CreateOrderStatusChangedEventMock.callArgs = []*StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams{}

	m.FetchNextOrderStatusChangedEventMock = mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent{mock: m}
	m.FetchNextOrderStatusChangedEventMock.callArgs = []*StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams{}

	m.MarkOrderStatusChangedEventAsSendMock = mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend{mock: m}
	m.MarkOrderStatusChangedEventAsSendMock.callArgs = []*StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent struct {
	optional           bool
	mock               *StatusOutboxRepositoryMock
	defaultExpectation *StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation
	expectations       []*StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation

	callArgs []*StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation specifies expectation struct of the StatusOutboxRepository.CreateOrderStatusChangedEvent
type StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation struct {
	mock      *StatusOutboxRepositoryMock
	params    *StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams
	paramPtrs *StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs
	results   *StatusOutboxRepositoryMockCreateOrderStatusChangedEventResults
	Counter   uint64
}

// StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams contains parameters of the StatusOutboxRepository.CreateOrderStatusChangedEvent
type StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams struct {
	ctx     context.Context
	orderID int64
	status  ordermodels.Status
}

// StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs contains pointers to parameters of the StatusOutboxRepository.CreateOrderStatusChangedEvent
type StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *ordermodels.Status
}

// StatusOutboxRepositoryMockCreateOrderStatusChangedEventResults contains results of the StatusOutboxRepository.CreateOrderStatusChangedEvent
type StatusOutboxRepositoryMockCreateOrderStatusChangedEventResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Optional() *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	mmCreateOrderStatusChangedEvent.optional = true
	return mmCreateOrderStatusChangedEvent
}

// Expect sets up expected params for StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Expect(ctx context.Context, orderID int64, status ordermodels.Status) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{}
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by ExpectParams functions")
	}

	mmCreateOrderStatusChangedEvent.defaultExpectation.params = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams{ctx, orderID, status}
	for _, e := range mmCreateOrderStatusChangedEvent.expectations {
		if minimock.Equal(e.params, mmCreateOrderStatusChangedEvent.defaultExpectation.params) {
			mmCreateOrderStatusChangedEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrderStatusChangedEvent.defaultExpectation.params)
		}
	}

	return mmCreateOrderStatusChangedEvent
}

// ExpectCtxParam1 sets up expected param ctx for StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) ExpectCtxParam1(ctx context.Context) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{}
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.params != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Expect")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs{}
	}
	mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateOrderStatusChangedEvent
}

// ExpectOrderIDParam2 sets up expected param orderID for StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) ExpectOrderIDParam2(orderID int64) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{}
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.params != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Expect")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs{}
	}
	mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs.orderID = &orderID

	return mmCreateOrderStatusChangedEvent
}

// ExpectStatusParam3 sets up expected param status for StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) ExpectStatusParam3(status ordermodels.Status) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{}
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.params != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Expect")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventParamPtrs{}
	}
	mmCreateOrderStatusChangedEvent.defaultExpectation.paramPtrs.status = &status

	return mmCreateOrderStatusChangedEvent
}

// Inspect accepts an inspector function that has same arguments as the StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Inspect(f func(ctx context.Context, orderID int64, status ordermodels.Status)) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if mmCreateOrderStatusChangedEvent.mock.inspectFuncCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("Inspect function is already set for StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent")
	}

	mmCreateOrderStatusChangedEvent.mock.inspectFuncCreateOrderStatusChangedEvent = f

	return mmCreateOrderStatusChangedEvent
}

// Return sets up results that will be returned by StatusOutboxRepository.CreateOrderStatusChangedEvent
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Return(err error) *StatusOutboxRepositoryMock {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	if mmCreateOrderStatusChangedEvent.defaultExpectation == nil {
		mmCreateOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{mock: mmCreateOrderStatusChangedEvent.mock}
	}
	mmCreateOrderStatusChangedEvent.defaultExpectation.results = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventResults{err}
	return mmCreateOrderStatusChangedEvent.mock
}

// Set uses given function f to mock the StatusOutboxRepository.CreateOrderStatusChangedEvent method
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Set(f func(ctx context.Context, orderID int64, status ordermodels.Status) (err error)) *StatusOutboxRepositoryMock {
	if mmCreateOrderStatusChangedEvent.defaultExpectation != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("Default expectation is already set for the StatusOutboxRepository.CreateOrderStatusChangedEvent method")
	}

	if len(mmCreateOrderStatusChangedEvent.expectations) > 0 {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("Some expectations are already set for the StatusOutboxRepository.CreateOrderStatusChangedEvent method")
	}

	mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent = f
	return mmCreateOrderStatusChangedEvent.mock
}

// When sets expectation for the StatusOutboxRepository.CreateOrderStatusChangedEvent which will trigger the result defined by the following
// Then helper
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) When(ctx context.Context, orderID int64, status ordermodels.Status) *StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation {
	if mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock is already set by Set")
	}

	expectation := &StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation{
		mock:   mmCreateOrderStatusChangedEvent.mock,
		params: &StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams{ctx, orderID, status},
	}
	mmCreateOrderStatusChangedEvent.expectations = append(mmCreateOrderStatusChangedEvent.expectations, expectation)
	return expectation
}

// Then sets up StatusOutboxRepository.CreateOrderStatusChangedEvent return parameters for the expectation previously defined by the When method
func (e *StatusOutboxRepositoryMockCreateOrderStatusChangedEventExpectation) Then(err error) *StatusOutboxRepositoryMock {
	e.results = &StatusOutboxRepositoryMockCreateOrderStatusChangedEventResults{err}
	return e.mock
}

// Times sets number of times StatusOutboxRepository.CreateOrderStatusChangedEvent should be invoked
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Times(n uint64) *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent {
	if n == 0 {
		mmCreateOrderStatusChangedEvent.mock.t.Fatalf("Times of StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrderStatusChangedEvent.expectedInvocations, n)
	return mmCreateOrderStatusChangedEvent
}

func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) invocationsDone() bool {
	if len(mmCreateOrderStatusChangedEvent.expectations) == 0 && mmCreateOrderStatusChangedEvent.defaultExpectation == nil && mmCreateOrderStatusChangedEvent.mock.funcCreateOrderStatusChangedEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrderStatusChangedEvent.mock.afterCreateOrderStatusChangedEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrderStatusChangedEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrderStatusChangedEvent implements order.StatusOutboxRepository
func (mmCreateOrderStatusChangedEvent *StatusOutboxRepositoryMock) CreateOrderStatusChangedEvent(ctx context.Context, orderID int64, status ordermodels.Status) (err error) {
	mm_atomic.AddUint64(&mmCreateOrderStatusChangedEvent.beforeCreateOrderStatusChangedEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrderStatusChangedEvent.afterCreateOrderStatusChangedEventCounter, 1)

	if mmCreateOrderStatusChangedEvent.inspectFuncCreateOrderStatusChangedEvent != nil {
		mmCreateOrderStatusChangedEvent.inspectFuncCreateOrderStatusChangedEvent(ctx, orderID, status)
	}

	mm_params := StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams{ctx, orderID, status}

	// Record call args
	mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.mutex.Lock()
	mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.callArgs = append(mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.callArgs, &mm_params)
	mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.mutex.Unlock()

	for _, e := range mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.defaultExpectation.paramPtrs

		mm_got := StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCreateOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmCreateOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrderStatusChangedEvent.CreateOrderStatusChangedEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrderStatusChangedEvent.t.Fatal("No results are set for the StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent")
		}
		return (*mm_results).err
	}
	if mmCreateOrderStatusChangedEvent.funcCreateOrderStatusChangedEvent != nil {
		return mmCreateOrderStatusChangedEvent.funcCreateOrderStatusChangedEvent(ctx, orderID, status)
	}
	mmCreateOrderStatusChangedEvent.t.Fatalf("Unexpected call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent. %v %v %v", ctx, orderID, status)
	return
}

// CreateOrderStatusChangedEventAfterCounter returns a count of finished StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent invocations
func (mmCreateOrderStatusChangedEvent *StatusOutboxRepositoryMock) CreateOrderStatusChangedEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderStatusChangedEvent.afterCreateOrderStatusChangedEventCounter)
}

// CreateOrderStatusChangedEventBeforeCounter returns a count of StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent invocations
func (mmCreateOrderStatusChangedEvent *StatusOutboxRepositoryMock) CreateOrderStatusChangedEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderStatusChangedEvent.beforeCreateOrderStatusChangedEventCounter)
}

// Calls returns a list of arguments used in each call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrderStatusChangedEvent *mStatusOutboxRepositoryMockCreateOrderStatusChangedEvent) Calls() []*StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams {
	mmCreateOrderStatusChangedEvent.mutex.RLock()

	argCopy := make([]*StatusOutboxRepositoryMockCreateOrderStatusChangedEventParams, len(mmCreateOrderStatusChangedEvent.callArgs))
	copy(argCopy, mmCreateOrderStatusChangedEvent.callArgs)

	mmCreateOrderStatusChangedEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderStatusChangedEventDone returns true if the count of the CreateOrderStatusChangedEvent invocations corresponds
// the number of defined expectations
func (m *StatusOutboxRepositoryMock) MinimockCreateOrderStatusChangedEventDone() bool {
	if m.CreateOrderStatusChangedEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderStatusChangedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderStatusChangedEventMock.invocationsDone()
}

// MinimockCreateOrderStatusChangedEventInspect logs each unmet expectation
func (m *StatusOutboxRepositoryMock) MinimockCreateOrderStatusChangedEventInspect() {
	for _, e := range m.CreateOrderStatusChangedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent with params: %#v", *e.params)
		}
	}

	afterCreateOrderStatusChangedEventCounter := mm_atomic.LoadUint64(&m.afterCreateOrderStatusChangedEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderStatusChangedEventMock.defaultExpectation != nil && afterCreateOrderStatusChangedEventCounter < 1 {
		if m.CreateOrderStatusChangedEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent")
		} else {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent with params: %#v", *m.CreateOrderStatusChangedEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderStatusChangedEvent != nil && afterCreateOrderStatusChangedEventCounter < 1 {
		m.t.Error("Expected call to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent")
	}

	if !m.CreateOrderStatusChangedEventMock.invocationsDone() && afterCreateOrderStatusChangedEventCounter > 0 {
		m.t.Errorf("Expected %d calls to StatusOutboxRepositoryMock.CreateOrderStatusChangedEvent but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderStatusChangedEventMock.expectedInvocations), afterCreateOrderStatusChangedEventCounter)
	}
}

type mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent struct {
	optional           bool
	mock               *StatusOutboxRepositoryMock
	defaultExpectation *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation
	expectations       []*StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation

	callArgs []*StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation specifies expectation struct of the StatusOutboxRepository.FetchNextOrderStatusChangedEvent
type StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation struct {
	mock      *StatusOutboxRepositoryMock
	params    *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams
	paramPtrs *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParamPtrs
	results   *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventResults
	Counter   uint64
}

// StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams contains parameters of the StatusOutboxRepository.FetchNextOrderStatusChangedEvent
type StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams struct {
	ctx context.Context
}

// StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParamPtrs contains pointers to parameters of the StatusOutboxRepository.FetchNextOrderStatusChangedEvent
type StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParamPtrs struct {
	ctx *context.Context
}

// StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventResults contains results of the StatusOutboxRepository.FetchNextOrderStatusChangedEvent
type StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventResults struct {
	s1  ordermodels.StatusChangedEvent
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Optional() *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent {
	mmFetchNextOrderStatusChangedEvent.optional = true
	return mmFetchNextOrderStatusChangedEvent
}

// Expect sets up expected params for StatusOutboxRepository.FetchNextOrderStatusChangedEvent
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Expect(ctx context.Context) *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent {
	if mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by Set")
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation == nil {
		mmFetchNextOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation{}
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation.paramPtrs != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by ExpectParams functions")
	}

	mmFetchNextOrderStatusChangedEvent.defaultExpectation.params = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams{ctx}
	for _, e := range mmFetchNextOrderStatusChangedEvent.expectations {
		if minimock.Equal(e.params, mmFetchNextOrderStatusChangedEvent.defaultExpectation.params) {
			mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchNextOrderStatusChangedEvent.defaultExpectation.params)
		}
	}

	return mmFetchNextOrderStatusChangedEvent
}

// ExpectCtxParam1 sets up expected param ctx for StatusOutboxRepository.FetchNextOrderStatusChangedEvent
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) ExpectCtxParam1(ctx context.Context) *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent {
	if mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by Set")
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation == nil {
		mmFetchNextOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation{}
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation.params != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by Expect")
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation.paramPtrs == nil {
		mmFetchNextOrderStatusChangedEvent.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParamPtrs{}
	}
	mmFetchNextOrderStatusChangedEvent.defaultExpectation.paramPtrs.ctx = &ctx

	return mmFetchNextOrderStatusChangedEvent
}

// Inspect accepts an inspector function that has same arguments as the StatusOutboxRepository.FetchNextOrderStatusChangedEvent
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Inspect(f func(ctx context.Context)) *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent {
	if mmFetchNextOrderStatusChangedEvent.mock.inspectFuncFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("Inspect function is already set for StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent")
	}

	mmFetchNextOrderStatusChangedEvent.mock.inspectFuncFetchNextOrderStatusChangedEvent = f

	return mmFetchNextOrderStatusChangedEvent
}

// Return sets up results that will be returned by StatusOutboxRepository.FetchNextOrderStatusChangedEvent
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Return(s1 ordermodels.StatusChangedEvent, err error) *StatusOutboxRepositoryMock {
	if mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by Set")
	}

	if mmFetchNextOrderStatusChangedEvent.defaultExpectation == nil {
		mmFetchNextOrderStatusChangedEvent.defaultExpectation = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation{mock: mmFetchNextOrderStatusChangedEvent.mock}
	}
	mmFetchNextOrderStatusChangedEvent.defaultExpectation.results = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventResults{s1, err}
	return mmFetchNextOrderStatusChangedEvent.mock
}

// Set uses given function f to mock the StatusOutboxRepository.FetchNextOrderStatusChangedEvent method
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Set(f func(ctx context.Context) (s1 ordermodels.StatusChangedEvent, err error)) *StatusOutboxRepositoryMock {
	if mmFetchNextOrderStatusChangedEvent.defaultExpectation != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("Default expectation is already set for the StatusOutboxRepository.FetchNextOrderStatusChangedEvent method")
	}

	if len(mmFetchNextOrderStatusChangedEvent.expectations) > 0 {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("Some expectations are already set for the StatusOutboxRepository.FetchNextOrderStatusChangedEvent method")
	}

	mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent = f
	return mmFetchNextOrderStatusChangedEvent.mock
}

// When sets expectation for the StatusOutboxRepository.FetchNextOrderStatusChangedEvent which will trigger the result defined by the following
// Then helper
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) When(ctx context.Context) *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation {
	if mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock is already set by Set")
	}

	expectation := &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation{
		mock:   mmFetchNextOrderStatusChangedEvent.mock,
		params: &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams{ctx},
	}
	mmFetchNextOrderStatusChangedEvent.expectations = append(mmFetchNextOrderStatusChangedEvent.expectations, expectation)
	return expectation
}

// Then sets up StatusOutboxRepository.FetchNextOrderStatusChangedEvent return parameters for the expectation previously defined by the When method
func (e *StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventExpectation) Then(s1 ordermodels.StatusChangedEvent, err error) *StatusOutboxRepositoryMock {
	e.results = &StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventResults{s1, err}
	return e.mock
}

// Times sets number of times StatusOutboxRepository.FetchNextOrderStatusChangedEvent should be invoked
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Times(n uint64) *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent {
	if n == 0 {
		mmFetchNextOrderStatusChangedEvent.mock.t.Fatalf("Times of StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFetchNextOrderStatusChangedEvent.expectedInvocations, n)
	return mmFetchNextOrderStatusChangedEvent
}

func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) invocationsDone() bool {
	if len(mmFetchNextOrderStatusChangedEvent.expectations) == 0 && mmFetchNextOrderStatusChangedEvent.defaultExpectation == nil && mmFetchNextOrderStatusChangedEvent.mock.funcFetchNextOrderStatusChangedEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFetchNextOrderStatusChangedEvent.mock.afterFetchNextOrderStatusChangedEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFetchNextOrderStatusChangedEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FetchNextOrderStatusChangedEvent implements order.StatusOutboxRepository
func (mmFetchNextOrderStatusChangedEvent *StatusOutboxRepositoryMock) FetchNextOrderStatusChangedEvent(ctx context.Context) (s1 ordermodels.StatusChangedEvent, err error) {
	mm_atomic.AddUint64(&mmFetchNextOrderStatusChangedEvent.beforeFetchNextOrderStatusChangedEventCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchNextOrderStatusChangedEvent.afterFetchNextOrderStatusChangedEventCounter, 1)

	if mmFetchNextOrderStatusChangedEvent.inspectFuncFetchNextOrderStatusChangedEvent != nil {
		mmFetchNextOrderStatusChangedEvent.inspectFuncFetchNextOrderStatusChangedEvent(ctx)
	}

	mm_params := StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams{ctx}

	// Record call args
	mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.mutex.Lock()
	mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.callArgs = append(mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.callArgs, &mm_params)
	mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.mutex.Unlock()

	for _, e := range mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.defaultExpectation.params
		mm_want_ptrs := mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.defaultExpectation.paramPtrs

		mm_got := StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFetchNextOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchNextOrderStatusChangedEvent.t.Errorf("StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchNextOrderStatusChangedEvent.FetchNextOrderStatusChangedEventMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchNextOrderStatusChangedEvent.t.Fatal("No results are set for the StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmFetchNextOrderStatusChangedEvent.funcFetchNextOrderStatusChangedEvent != nil {
		return mmFetchNextOrderStatusChangedEvent.funcFetchNextOrderStatusChangedEvent(ctx)
	}
	mmFetchNextOrderStatusChangedEvent.t.Fatalf("Unexpected call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent. %v", ctx)
	return
}

// FetchNextOrderStatusChangedEventAfterCounter returns a count of finished StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent invocations
func (mmFetchNextOrderStatusChangedEvent *StatusOutboxRepositoryMock) FetchNextOrderStatusChangedEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextOrderStatusChangedEvent.afterFetchNextOrderStatusChangedEventCounter)
}

// FetchNextOrderStatusChangedEventBeforeCounter returns a count of StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent invocations
func (mmFetchNextOrderStatusChangedEvent *StatusOutboxRepositoryMock) FetchNextOrderStatusChangedEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextOrderStatusChangedEvent.beforeFetchNextOrderStatusChangedEventCounter)
}

// Calls returns a list of arguments used in each call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchNextOrderStatusChangedEvent *mStatusOutboxRepositoryMockFetchNextOrderStatusChangedEvent) Calls() []*StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams {
	mmFetchNextOrderStatusChangedEvent.mutex.RLock()

	argCopy := make([]*StatusOutboxRepositoryMockFetchNextOrderStatusChangedEventParams, len(mmFetchNextOrderStatusChangedEvent.callArgs))
	copy(argCopy, mmFetchNextOrderStatusChangedEvent.callArgs)

	mmFetchNextOrderStatusChangedEvent.mutex.RUnlock()

	return argCopy
}

// MinimockFetchNextOrderStatusChangedEventDone returns true if the count of the FetchNextOrderStatusChangedEvent invocations corresponds
// the number of defined expectations
func (m *StatusOutboxRepositoryMock) MinimockFetchNextOrderStatusChangedEventDone() bool {
	if m.FetchNextOrderStatusChangedEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FetchNextOrderStatusChangedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FetchNextOrderStatusChangedEventMock.invocationsDone()
}

// MinimockFetchNextOrderStatusChangedEventInspect logs each unmet expectation
func (m *StatusOutboxRepositoryMock) MinimockFetchNextOrderStatusChangedEventInspect() {
	for _, e := range m.FetchNextOrderStatusChangedEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent with params: %#v", *e.params)
		}
	}

	afterFetchNextOrderStatusChangedEventCounter := mm_atomic.LoadUint64(&m.afterFetchNextOrderStatusChangedEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FetchNextOrderStatusChangedEventMock.defaultExpectation != nil && afterFetchNextOrderStatusChangedEventCounter < 1 {
		if m.FetchNextOrderStatusChangedEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent")
		} else {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent with params: %#v", *m.FetchNextOrderStatusChangedEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchNextOrderStatusChangedEvent != nil && afterFetchNextOrderStatusChangedEventCounter < 1 {
		m.t.Error("Expected call to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent")
	}

	if !m.FetchNextOrderStatusChangedEventMock.invocationsDone() && afterFetchNextOrderStatusChangedEventCounter > 0 {
		m.t.Errorf("Expected %d calls to StatusOutboxRepositoryMock.FetchNextOrderStatusChangedEvent but found %d calls",
			mm_atomic.LoadUint64(&m.FetchNextOrderStatusChangedEventMock.expectedInvocations), afterFetchNextOrderStatusChangedEventCounter)
	}
}

type mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend struct {
	optional           bool
	mock               *StatusOutboxRepositoryMock
	defaultExpectation *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation
	expectations       []*StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation

	callArgs []*StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation specifies expectation struct of the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
type StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation struct {
	mock      *StatusOutboxRepositoryMock
	params    *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams
	paramPtrs *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParamPtrs
	results   *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendResults
	Counter   uint64
}

// StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams contains parameters of the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
type StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams struct {
	ctx     context.Context
	eventID int64
}

// StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParamPtrs contains pointers to parameters of the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
type StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParamPtrs struct {
	ctx     *context.Context
	eventID *int64
}

// StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendResults contains results of the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
type StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Optional() *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	mmMarkOrderStatusChangedEventAsSend.optional = true
	return mmMarkOrderStatusChangedEventAsSend
}

// Expect sets up expected params for StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Expect(ctx context.Context, eventID int64) *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	if mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Set")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation{}
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by ExpectParams functions")
	}

	mmMarkOrderStatusChangedEventAsSend.defaultExpectation.params = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams{ctx, eventID}
	for _, e := range mmMarkOrderStatusChangedEventAsSend.expectations {
		if minimock.Equal(e.params, mmMarkOrderStatusChangedEventAsSend.defaultExpectation.params) {
			mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkOrderStatusChangedEventAsSend.defaultExpectation.params)
		}
	}

	return mmMarkOrderStatusChangedEventAsSend
}

// ExpectCtxParam1 sets up expected param ctx for StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) ExpectCtxParam1(ctx context.Context) *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	if mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Set")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation{}
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation.params != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Expect")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParamPtrs{}
	}
	mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs.ctx = &ctx

	return mmMarkOrderStatusChangedEventAsSend
}

// ExpectEventIDParam2 sets up expected param eventID for StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) ExpectEventIDParam2(eventID int64) *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	if mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Set")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation{}
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation.params != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Expect")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParamPtrs{}
	}
	mmMarkOrderStatusChangedEventAsSend.defaultExpectation.paramPtrs.eventID = &eventID

	return mmMarkOrderStatusChangedEventAsSend
}

// Inspect accepts an inspector function that has same arguments as the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Inspect(f func(ctx context.Context, eventID int64)) *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	if mmMarkOrderStatusChangedEventAsSend.mock.inspectFuncMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("Inspect function is already set for StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend")
	}

	mmMarkOrderStatusChangedEventAsSend.mock.inspectFuncMarkOrderStatusChangedEventAsSend = f

	return mmMarkOrderStatusChangedEventAsSend
}

// Return sets up results that will be returned by StatusOutboxRepository.MarkOrderStatusChangedEventAsSend
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Return(err error) *StatusOutboxRepositoryMock {
	if mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Set")
	}

	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation == nil {
		mmMarkOrderStatusChangedEventAsSend.defaultExpectation = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation{mock: mmMarkOrderStatusChangedEventAsSend.mock}
	}
	mmMarkOrderStatusChangedEventAsSend.defaultExpectation.results = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendResults{err}
	return mmMarkOrderStatusChangedEventAsSend.mock
}

// Set uses given function f to mock the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend method
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Set(f func(ctx context.Context, eventID int64) (err error)) *StatusOutboxRepositoryMock {
	if mmMarkOrderStatusChangedEventAsSend.defaultExpectation != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("Default expectation is already set for the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend method")
	}

	if len(mmMarkOrderStatusChangedEventAsSend.expectations) > 0 {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("Some expectations are already set for the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend method")
	}

	mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend = f
	return mmMarkOrderStatusChangedEventAsSend.mock
}

// When sets expectation for the StatusOutboxRepository.MarkOrderStatusChangedEventAsSend which will trigger the result defined by the following
// Then helper
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) When(ctx context.Context, eventID int64) *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation {
	if mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock is already set by Set")
	}

	expectation := &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation{
		mock:   mmMarkOrderStatusChangedEventAsSend.mock,
		params: &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams{ctx, eventID},
	}
	mmMarkOrderStatusChangedEventAsSend.expectations = append(mmMarkOrderStatusChangedEventAsSend.expectations, expectation)
	return expectation
}

// Then sets up StatusOutboxRepository.MarkOrderStatusChangedEventAsSend return parameters for the expectation previously defined by the When method
func (e *StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendExpectation) Then(err error) *StatusOutboxRepositoryMock {
	e.results = &StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendResults{err}
	return e.mock
}

// Times sets number of times StatusOutboxRepository.MarkOrderStatusChangedEventAsSend should be invoked
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Times(n uint64) *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend {
	if n == 0 {
		mmMarkOrderStatusChangedEventAsSend.mock.t.Fatalf("Times of StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkOrderStatusChangedEventAsSend.expectedInvocations, n)
	return mmMarkOrderStatusChangedEventAsSend
}

func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) invocationsDone() bool {
	if len(mmMarkOrderStatusChangedEventAsSend.expectations) == 0 && mmMarkOrderStatusChangedEventAsSend.defaultExpectation == nil && mmMarkOrderStatusChangedEventAsSend.mock.funcMarkOrderStatusChangedEventAsSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkOrderStatusChangedEventAsSend.mock.afterMarkOrderStatusChangedEventAsSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkOrderStatusChangedEventAsSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkOrderStatusChangedEventAsSend implements order.StatusOutboxRepository
func (mmMarkOrderStatusChangedEventAsSend *StatusOutboxRepositoryMock) MarkOrderStatusChangedEventAsSend(ctx context.Context, eventID int64) (err error) {
	mm_atomic.AddUint64(&mmMarkOrderStatusChangedEventAsSend.beforeMarkOrderStatusChangedEventAsSendCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkOrderStatusChangedEventAsSend.afterMarkOrderStatusChangedEventAsSendCounter, 1)

	if mmMarkOrderStatusChangedEventAsSend.inspectFuncMarkOrderStatusChangedEventAsSend != nil {
		mmMarkOrderStatusChangedEventAsSend.inspectFuncMarkOrderStatusChangedEventAsSend(ctx, eventID)
	}

	mm_params := StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams{ctx, eventID}

	// Record call args
	mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.mutex.Lock()
	mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.callArgs = append(mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.callArgs, &mm_params)
	mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.mutex.Unlock()

	for _, e := range mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.params
		mm_want_ptrs := mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.paramPtrs

		mm_got := StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams{ctx, eventID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkOrderStatusChangedEventAsSend.t.Errorf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmMarkOrderStatusChangedEventAsSend.t.Errorf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend got unexpected parameter eventID, want: %#v, got: %#v%s\n", *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkOrderStatusChangedEventAsSend.t.Errorf("StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkOrderStatusChangedEventAsSend.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkOrderStatusChangedEventAsSend.t.Fatal("No results are set for the StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend")
		}
		return (*mm_results).err
	}
	if mmMarkOrderStatusChangedEventAsSend.funcMarkOrderStatusChangedEventAsSend != nil {
		return mmMarkOrderStatusChangedEventAsSend.funcMarkOrderStatusChangedEventAsSend(ctx, eventID)
	}
	mmMarkOrderStatusChangedEventAsSend.t.Fatalf("Unexpected call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend. %v %v", ctx, eventID)
	return
}

// MarkOrderStatusChangedEventAsSendAfterCounter returns a count of finished StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend invocations
func (mmMarkOrderStatusChangedEventAsSend *StatusOutboxRepositoryMock) MarkOrderStatusChangedEventAsSendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkOrderStatusChangedEventAsSend.afterMarkOrderStatusChangedEventAsSendCounter)
}

// MarkOrderStatusChangedEventAsSendBeforeCounter returns a count of StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend invocations
func (mmMarkOrderStatusChangedEventAsSend *StatusOutboxRepositoryMock) MarkOrderStatusChangedEventAsSendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkOrderStatusChangedEventAsSend.beforeMarkOrderStatusChangedEventAsSendCounter)
}

// Calls returns a list of arguments used in each call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkOrderStatusChangedEventAsSend *mStatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSend) Calls() []*StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams {
	mmMarkOrderStatusChangedEventAsSend.mutex.RLock()

	argCopy := make([]*StatusOutboxRepositoryMockMarkOrderStatusChangedEventAsSendParams, len(mmMarkOrderStatusChangedEventAsSend.callArgs))
	copy(argCopy, mmMarkOrderStatusChangedEventAsSend.callArgs)

	mmMarkOrderStatusChangedEventAsSend.mutex.RUnlock()

	return argCopy
}

// MinimockMarkOrderStatusChangedEventAsSendDone returns true if the count of the MarkOrderStatusChangedEventAsSend invocations corresponds
// the number of defined expectations
func (m *StatusOutboxRepositoryMock) MinimockMarkOrderStatusChangedEventAsSendDone() bool {
	if m.MarkOrderStatusChangedEventAsSendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkOrderStatusChangedEventAsSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkOrderStatusChangedEventAsSendMock.invocationsDone()
}

// MinimockMarkOrderStatusChangedEventAsSendInspect logs each unmet expectation
func (m *StatusOutboxRepositoryMock) MinimockMarkOrderStatusChangedEventAsSendInspect() {
	for _, e := range m.MarkOrderStatusChangedEventAsSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend with params: %#v", *e.params)
		}
	}

	afterMarkOrderStatusChangedEventAsSendCounter := mm_atomic.LoadUint64(&m.afterMarkOrderStatusChangedEventAsSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkOrderStatusChangedEventAsSendMock.defaultExpectation != nil && afterMarkOrderStatusChangedEventAsSendCounter < 1 {
		if m.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend")
		} else {
			m.t.Errorf("Expected call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend with params: %#v", *m.MarkOrderStatusChangedEventAsSendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkOrderStatusChangedEventAsSend != nil && afterMarkOrderStatusChangedEventAsSendCounter < 1 {
		m.t.Error("Expected call to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend")
	}

	if !m.MarkOrderStatusChangedEventAsSendMock.invocationsDone() && afterMarkOrderStatusChangedEventAsSendCounter > 0 {
		m.t.Errorf("Expected %d calls to StatusOutboxRepositoryMock.MarkOrderStatusChangedEventAsSend but found %d calls",
			mm_atomic.LoadUint64(&m.MarkOrderStatusChangedEventAsSendMock.expectedInvocations), afterMarkOrderStatusChangedEventAsSendCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StatusOutboxRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderStatusChangedEventInspect()

			m.MinimockFetchNextOrderStatusChangedEventInspect()

			m.MinimockMarkOrderStatusChangedEventAsSendInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StatusOutboxRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StatusOutboxRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderStatusChangedEventDone() &&
		m.MinimockFetchNextOrderStatusChangedEventDone() &&
		m.MinimockMarkOrderStatusChangedEventAsSendDone()
}
